<!DOCTYPE html>
<html lang="en">
  <head>
    <title>QCloudCOSXML  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset='utf-8'>
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
  </head>
  <body>
    <a title="QCloudCOSXML  Reference"></a>
    <header>
      <div class="content-wrapper">
        <p><a href="index.html">QCloudCOSXML Docs</a></p>
      </div>
    </header>
    <div class="content-wrapper">
      <p id="breadcrumbs">
        <a href="index.html">QCloudCOSXML Reference</a>
        <img id="carat" src="img/carat.png" />
        QCloudCOSXML  Reference
      </p>
    </div>
    <div class="content-wrapper">
      <nav class="sidebar">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Classes/QCloudACLGrant.html">QCloudACLGrant</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudACLGrantee.html">QCloudACLGrantee</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudACLOwner.html">QCloudACLOwner</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudACLPolicy.html">QCloudACLPolicy</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudAppendObjectRequest.html">QCloudAppendObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudBucketContents.html">QCloudBucketContents</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudBucketLocationConstraint.html">QCloudBucketLocationConstraint</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudBucketOwner.html">QCloudBucketOwner</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudBucketTag.html">QCloudBucketTag</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudBucketTagging.html">QCloudBucketTagging</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCORSConfiguration.html">QCloudCORSConfiguration</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCORSRule.html">QCloudCORSRule</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCOSTransferMangerService.html">QCloudCOSTransferMangerService</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCOSXMLEndPoint.html">QCloudCOSXMLEndPoint</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCOSXMLService.html">QCloudCOSXMLService</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCOSXMLUploadObjectRequest.html">QCloudCOSXMLUploadObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudCommonPrefixes.html">QCloudCommonPrefixes</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteBucketCORSRequest.html">QCloudDeleteBucketCORSRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteBucketTaggingRequest.html">QCloudDeleteBucketTaggingRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteInfo.html">QCloudDeleteInfo</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteMultipleObjectRequest.html">QCloudDeleteMultipleObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteObjectInfo.html">QCloudDeleteObjectInfo</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteObjectRequest.html">QCloudDeleteObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteResult.html">QCloudDeleteResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudDeleteResultRow.html">QCloudDeleteResultRow</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetBucketACLRequest.html">QCloudGetBucketACLRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetBucketCORSRequest.html">QCloudGetBucketCORSRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetBucketLocationRequest.html">QCloudGetBucketLocationRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetBucketRequest.html">QCloudGetBucketRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetBucketTaggingRequest.html">QCloudGetBucketTaggingRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetObjectACLRequest.html">QCloudGetObjectACLRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudGetObjectRequest.html">QCloudGetObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudHeadBucketRequest.html">QCloudHeadBucketRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudHeadObjectRequest.html">QCloudHeadObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudInitiateMultipartUploadRequest.html">QCloudInitiateMultipartUploadRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudInitiateMultipartUploadResult.html">QCloudInitiateMultipartUploadResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudListBucketMultipartUploadsRequest.html">QCloudListBucketMultipartUploadsRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudListBucketResult.html">QCloudListBucketResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudListMultipartUploadContent.html">QCloudListMultipartUploadContent</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudListMultipartUploadsResult.html">QCloudListMultipartUploadsResult</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudMultipartUploadInitiator.html">QCloudMultipartUploadInitiator</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudMultipartUploadOwner.html">QCloudMultipartUploadOwner</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudOptionsObjectRequest.html">QCloudOptionsObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudPutBucketACLRequest.html">QCloudPutBucketACLRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudPutBucketCORSRequest.html">QCloudPutBucketCORSRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudPutBucketTaggingRequest.html">QCloudPutBucketTaggingRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudPutObjectACLRequest.html">QCloudPutObjectACLRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudPutObjectRequest.html">QCloudPutObjectRequest</a>
              </li>
              <li class="nav-group-task">
                <a href="Classes/QCloudUploadObjectResult.html">QCloudUploadObjectResult</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Constants.html">Constants</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Constants.html#/c:@QCloudUploadResumeDataKey">QCloudUploadResumeDataKey</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Enums.html">Enums</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Enums/QCloudCOSAccountType.html">QCloudCOSAccountType</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/QCloudCOSPermission.html">QCloudCOSPermission</a>
              </li>
              <li class="nav-group-task">
                <a href="Enums/QCloudCOSStorageClass.html">QCloudCOSStorageClass</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Type Definitions.html">Type Definitions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Type Definitions.html#/c:QCloudCOSXMLUploadObjectRequest.h@T@QCloudCOSXMLUploadObjectResumeData">QCloudCOSXMLUploadObjectResumeData</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a href="Functions.html">Functions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSAccountTypeDumpFromString">QCloudCOSAccountTypeDumpFromString</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSAccountTypeTransferToString">QCloudCOSAccountTypeTransferToString</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSPermissionDumpFromString">QCloudCOSPermissionDumpFromString</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSPermissionTransferToString">QCloudCOSPermissionTransferToString</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSStorageClassDumpFromString">QCloudCOSStorageClassDumpFromString</a>
              </li>
              <li class="nav-group-task">
                <a href="Functions.html#/c:@F@QCloudCOSStorageClassTransferToString">QCloudCOSStorageClassTransferToString</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">
        <section>
          <section class="section">
            
            <h2 id='' class='heading'>开发准备</h2>
<h3 id='sdk' class='heading'>SDK 获取</h3>

<p>对象存储服务的 iOS SDK 的下载地址：<a href="https://github.com/tencentyun/cos_xml_iOS_sdk.git">iOS SDK</a></p>

<p>更多示例可参考Demo：<a href="https://github.com/tencentyun/cos_xml_iOS_sdk.git">iOS Demo</a>
（本版本SDK基于XML API封装组成）</p>
<h3 id='' class='heading'>开发准备</h3>

<ul>
<li>iOS 8.0+；</li>
<li>手机必须要有网络（GPRS、3G或Wifi网络等）；</li>
</ul>
<h3 id='sdk' class='heading'>SDK 配置</h3>
<h4 id='sdk' class='heading'>SDK 导入</h4>

<p>您可以通过cocoapods或者下载打包好的动态库的方式来集成SDK。在这里我们推荐您使用cocoapods的方式来进行导入。</p>
<h5 id='cocoapods' class='heading'>使用Cocoapods导入(推荐)</h5>

<p>在Podfile文件中使用：</p>
<pre class="highlight plaintext"><code>pod "QCloudCOSXML"
</code></pre>
<h5 id='' class='heading'>使用打包好的动态库导入</h5>

<p>将<strong>QCloudCOSXML.framework和QCloudCore.framework</strong>拖入到工程中即可：</p>

<p><img src="http://ericcheungtest-1251668577.cosgz.myqcloud.com/framework%E6%88%AA%E5%9B%BE.png" alt=""></p>

<p>并添加以下依赖库：</p>

<ol>
<li>CoreTelephony</li>
<li>Foundation</li>
<li>SystemConfiguration</li>
<li>libstdc++.tbd</li>
</ol>
<h4 id='' class='heading'>工程配置</h4>

<p>在 Build Settings 中设置 Other Linker Flags，加入参数 -ObjC。</p>

<p><img src="https://mccdn.qcloud.com/static/img/58327ba5d83809c77da158ff95627ef7/image.png" alt="参数配置"></p>

<p>在工程info.plist文件中添加App Transport Security Settings 类型，然后在App Transport Security Settings下添加Allow Arbitrary Loads 类型Boolean,值设为YES。</p>
<h3 id='' class='heading'>初始化</h3>

<p>在使用SDK的功能之前，我们需要导入一些必要的头文件和进行一些初始化工作。</p>

<p>引入上传 SDK 的头文件 <em>QCloudCore/QCloudCore.h,<br>
 QCloudCore/QCloudCredential.h,<br>
 QCloudCore/QCloudAuthentationCreator.h,<br>
 QCloudCore/QCloudServiceConfiguration_Private.h,<br>
 QCloudCOSXML/QCloudCOSXML.h</em>，<br>
 使用 SDK 操作时，需要先实例化 <em>QCloudCOSXMLService</em> 和 <em>QCloudCOSTransferManagerService</em> 对象。实例化这两个对象之前我们要实例化一个云服务配置对象<em>QCloudServiceConfiguration</em>。</p>
<h4 id='' class='heading'>方法原型</h4>
<pre class="highlight plaintext"><code> QCloudServiceConfiguration* configuration = [QCloudServiceConfiguration new];
 configuration.appID = @""//项目ID;
 configuration.regionType = QCloudRegionCNNorth;
</code></pre>
<pre class="highlight plaintext"><code>+ (QCloudCOSXMLService*) registerDefaultCOSXMLWithConfiguration:(QCloudServiceConfiguration*)configuration;
</code></pre>
<pre class="highlight plaintext"><code>+ (QCloudCOSTransferMangerService*) registerDefaultCOSTransferMangerWithConfiguration:(QCloudServiceConfiguration*)configuration;
</code></pre>
<h4 id='' class='heading'>参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>appID</td>
<td>NSString *</td>
<td>是</td>
<td>项目ID，即APP ID。</td>
</tr>
<tr>
<td>regionType</td>
<td>QCloudRegionType</td>
<td>是</td>
<td>bucket被创建的时候机房区域，比如华南园区：QCloudRegionCNSouth，华北园区：QCloudRegionCNNorth</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>//AppDelegate.m

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
 QCloudServiceConfiguration* configuration = [QCloudServiceConfiguration new];
    configuration.appID = @"1234567";
    configuration.signatureProvider = self;
    configuration.regionType = QCloudRegionCNNorth;
    configuration.endPoint = [[QCloudEndPoint alloc] initWithRegionType:currentRegion serviceType:QCloudServiceCOSXML useSSL:NO];
    [QCloudCOSXMLService registerDefaultCOSXMLWithConfiguration:configuration];
    [QCloudCOSTransferMangerService registerDefaultCOSTransferMangerWithConfiguration:configuration];
    return YES
}

</code></pre>
<h2 id='' class='heading'>快速入门</h2>

<p>这里演示的上传和下载的基本流程，更多细节可以参考demo；在进行这一步之前必须在腾讯云控制台上申请COS业务的appid；</p>
<h3 id='step-1' class='heading'>STEP - 1 初始化</h3>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>//AppDelegate.m
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

QCloudServiceConfiguration* configuration = [QCloudServiceConfiguration new];
configuration.appID = @"1234567";
configuration.signatureProvider = self;
configuration.regionType = QCloudRegionCNNorth;
configuration.endPoint = [[QCloudEndPoint alloc] initWithRegionType:currentRegion serviceType:QCloudServiceCOSXML useSSL:NO];
[QCloudCOSXMLService registerDefaultCOSXMLWithConfiguration:configuration];
[QCloudCOSTransferMangerService registerDefaultCOSTransferMangerWithConfiguration:configuration];
}
</code></pre>

<p>需要注意的是QCloudServiceConfiguration的signatureProvider对象需要实现QCloudSignatureProvider协议。 </p>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>//AppDelegate.m
- (void) signatureWithFields:(QCloudSignatureFields*)fileds
                     request:(QCloudBizHTTPRequest*)request
                  urlRequest:(NSURLRequest*)urlRequst
                   compelete:(QCloudHTTPAuthentationContinueBlock)continueBlock
{
    QCloudCredential* credential = [QCloudCredential new];
    credential.secretID = @"您的SecretID";
    credential.secretKey = @"您的SecretKey";
    QCloudAuthentationCreator* creator = [[QCloudAuthentationCreator alloc] initWithCredential:credential];
    QCloudSignature* signature =  [creator signatureForCOSXMLRequest:request];
    continueBlock(signature, nil);
}

</code></pre>
<h3 id='step-2' class='heading'>STEP - 2 上传文件</h3>

<p>在这里我们假设您已经申请了自己业务bucket。事实上，SDK所有的请求对应了相应的Request类，只要生成相应的请求，设置好相应的属性，然后将请求交给QCloudCOSXMLService对象，就可以完成相应的动作。其中，request的body部分传入需要上传的文件在本地的URL（NSURL* 类型）。    </p>

<p>上传文件的接口需要用到签名来进行身份认证，我们的请求会自动向初始化时指定的遵循QCloudSignatureProvider协议的对象去请求签名。签名如何生成可以参考下一章节中的生成签名。</p>

<p>需要留意的是，URL所对应的文件在上传过程中是不能进行变更的，否则会导致出错。</p>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>  QCloudCOSXMLUploadObjectRequest* put = [QCloudCOSXMLUploadObjectRequest new];

    NSURL* url = /*文件的URL*/;
    put.object = @"文件名.jpg";
    put.bucket = /*bucket名*/;
    put.body =  url;
    [put setSendProcessBlock:^(int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend) {
        NSLog(@"upload %lld totalSend %lld aim %lld", bytesSent, totalBytesSent, totalBytesExpectedToSend);
    }];
    [put setFinishBlock:^(id outputObject, NSError *error) {

    }];
    [[QCloudCOSTransferMangerService defaultCOSTRANSFERMANGER] UploadObject:put];

</code></pre>
<h4 id='qcloudcosxmluploadobjectrequest' class='heading'>QCloudCOSXMLUploadObjectRequest参数含义</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>Object</td>
<td>NSString *</td>
<td>是</td>
<td>上传文件（对象）的文件名，也是对象的key</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>上传的存储桶的名称</td>
</tr>
<tr>
<td>body</td>
<td>BodyType</td>
<td>是</td>
<td>需要上传的文件的路径。填入NSURL * 类型变量</td>
</tr>
<tr>
<td>storageClass</td>
<td>QCloudCOSStorageClass</td>
<td>是</td>
<td>对象的存储级别</td>
</tr>
<tr>
<td>cacheControl</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的缓存策略</td>
</tr>
<tr>
<td>contentDisposition</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的文件名称</td>
</tr>
<tr>
<td>expect</td>
<td>NSString *</td>
<td>否</td>
<td>当使用expect=@<q>100-Continue</q>时，在收到服务端确认后才会发送请求内容</td>
</tr>
<tr>
<td>expires</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的过期时间</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSString *</td>
<td>否</td>
<td>定义 Object 的 ACL 属性。有效值：private，public-read-write，public-read；默认值：private</td>
</tr>
<tr>
<td>grantRead</td>
<td>NSString *</td>
<td>否</td>
<td>赋予被授权者读的权限。格式： id=&ldquo; <q>,id=</q> <q>；当需要给子账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;SubUin&gt;<q>，当需要给根账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;OwnerUin&gt;&rdquo;  其中OwnerUin指的是根账户的ID，而SubUin指的是子账户的ID</td>
</tr>
<tr>
<td>grantWrite</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者写的权限。格式同上。</td>
</tr>
<tr>
<td>grantFullControl</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者读写权限。格式同上。</td>
</tr>
</tbody></table>
<h3 id='step-3' class='heading'>STEP - 3 下载文件</h3>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>  QCloudGetObjectRequest* request = [QCloudGetObjectRequest new];
  //设置下载的路径URL，如果设置了，文件将会被下载到指定路径中
  request.downloadingURL = [NSURL URLWithString:QCloudTempFilePathWithExtension(@"downding")];
  request.object = @“你的Object-Key”;
  request.bucket = @"你的bucket名";
  [request setFinishBlock:^(id outputObject, NSError *error) {
    //additional actions after finishing
}];
    [request setDownProcessBlock:^(int64_t bytesDownload, int64_t totalBytesDownload, int64_t totalBytesExpectedToDownload) {
     //下载过程中的进度
    }];
    [[QCloudCOSXMLService defaultCOSXML] GetObject:request];
</code></pre>
<h2 id='' class='heading'>生成签名</h2>

<p>SDK中的请求需要用到签名，以确访问的用户的身份，也保障了访问的安全性。在SDK中可以生成签名，每个请求会向QCloudServiceConfiguration对象中的signatureProvider对象来请求生成签名。我们可以将负责生成签名的对象在一开始赋值给signatureProvider，该生成签名的对象需要遵循QCloudSignatureProvider协议，并实现生成签名的方法：</p>

<pre objective-c>
- (void) signatureWithFields:(QCloudSignatureFields* )fileds    
                     request:(QCloudBizHTTPRequest* )request    
                  urlRequest:(NSURLRequest* )urlRequst    
                   compelete:(QCloudHTTPAuthentationContinueBlock)continueBlock
</pre>

<p>基于安全性的考虑，我们建议您在服务器端实现签名的过程。您也可以在本地生成签名，请参考例子：</p>
<pre class="highlight plaintext"><code>- (void) signatureWithFields:(QCloudSignatureFields*)fileds
                     request:(QCloudBizHTTPRequest*)request
                  urlRequest:(NSURLRequest*)urlRequst
                   compelete:(QCloudHTTPAuthentationContinueBlock)continueBlock
{
    QCloudCredential* credential = [QCloudCredential new];
    credential.secretID = @"您的secretID";
    credential.secretKey = @"您的scretKey";

    QCloudAuthentationCreator* creator = [[QCloudAuthentationCreator alloc] initWithCredential:credential];
    QCloudSignature* signature =  [creator signatureForCOSXMLRequest:request];
    continueBlock(signature, nil);
}

</code></pre>
<h2 id='' class='heading'>存储桶操作</h2>
<h3 id='' class='heading'>列举存储桶内的内容</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudGetBucketRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudGetBucketRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的GetBucket方法发出请求。<br>
3.从回调的finishBlock中的QCloudListBucketResult获取具体内容。    </p>
<h4 id='qcloudgetbucketrequest' class='heading'>QCloudGetBucketRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>region</td>
<td>NSString *</td>
<td>否</td>
<td>前缀匹配，用来规定返回的文件前缀地址</td>
</tr>
<tr>
<td>delimiter</td>
<td>NSString *</td>
<td>否</td>
<td>定界符为一个符号，如果有 Prefix，则将 Prefix 到 delimiter 之间的相同路径归为一类，定义为 Common Prefix，然后列出所有 Common Prefix。如果没有 Prefix，则从路径起点开始</td>
</tr>
<tr>
<td>encodingType</td>
<td>NSString *</td>
<td>否</td>
<td>规定返回值的编码方式，可选值:url</td>
</tr>
<tr>
<td>marker</td>
<td>NSString *</td>
<td>否</td>
<td>默认以UTF-8二进制顺序列出条目，所有列出条目从marker开始</td>
</tr>
<tr>
<td>maxKeys</td>
<td>int</td>
<td>否</td>
<td>单次返回的最大条目数量，默认1000</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>    QCloudGetBucketRequest* request = [QCloudGetBucketRequest new];
    request.bucket = @“testBucket”;
    request.maxKeys = 1000;
    [request setFinishBlock:^(QCloudListBucketResult * _Nonnull result, NSError * _Nonnull error) {
    //additional actions after finishing
    }];
    [[QCloudCOSXMLService defaultCOSXML] GetBucket:request];
</code></pre>
<h3 id='acl-access-control-list' class='heading'>获取存储桶的ACL（Access Control List）</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudGetBucketACLRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudGetBucketACLRequest，填入获取ACL的bucket。<br>
2.调用QCloudCOSXMLService对象中的GetBucketACL方法发出请求。<br>
3.从回调的finishBlock中的QCloudACLPolicy获取具体内容。    </p>
<h4 id='qcloudgetbucketaclrequest' class='heading'>QCloudGetBucketACLRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
</tbody></table>
<h4 id='qcloudaclpolicy' class='heading'>返回结果QCloudACLPolicy参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>owner</td>
<td>QCloudACLOwner *</td>
<td>存储桶持有者的信息</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSArray *</td>
<td>被授权者与权限的信息</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>  QCloudGetBucketACLRequest* getBucketACl   = [QCloudGetBucketACLRequest new];
    getBucketACl.bucket = self.bucket;
    [getBucketACl setFinishBlock:^(QCloudACLPolicy * _Nonnull result, NSError * _Nonnull error) {
        //QCloudACLPolicy中包含了bucket的ACL信息。
    }];

    [[QCloudCOSXMLService defaultCOSXML] GetBucketACL:getBucketACl];

</code></pre>
<h3 id='acl-access-control-list' class='heading'>设置存储桶的ACL(Access Control List)</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudPutBucketACLRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudPutBucketACLRequest，填入需要设置的bucket，然后根据设置值的权限类型分别填入不同的参数。<br>
2.调用QCloudCOSXMLService对象中的PutBucketACL方法发出请求。<br>
3.从回调的finishBlock中的获取设置是否成功，并做设置成功后的一些额外动作。   </p>
<h4 id='qcloudputbucketaclrequest' class='heading'>QCloudPutBucketACLRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSString *</td>
<td>否</td>
<td>定义 Object 的 ACL 属性。有效值：private，public-read-write，public-read；默认值：private</td>
</tr>
<tr>
<td>grantRead</td>
<td>NSString *</td>
<td>否</td>
<td>赋予被授权者读的权限。格式： id=&ldquo; <q>,id=</q> <q>；当需要给子账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;SubUin&gt;<q>，当需要给根账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;OwnerUin&gt;&rdquo;  其中OwnerUin指的是根账户的ID，而SubUin指的是子账户的ID</td>
</tr>
<tr>
<td>grantWrite</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者写的权限。格式同上。</td>
</tr>
<tr>
<td>grantFullControl</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者读写权限。格式同上。</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>    QCloudPutBucketACLRequest* putACL = [QCloudPutBucketACLRequest new];
    NSString* appID = @“您的APP ID”;
    NSString *ownerIdentifier = [NSString stringWithFormat:@"qcs::cam::uin/%@:uin/%@", appID, appID];
    NSString *grantString = [NSString stringWithFormat:@"id=\"%@\"",ownerIdentifier];
    putACL.grantFullControl = grantString;
    putACL.bucket = @“您要操作的bucket名”;
    [putACL setFinishBlock:^(id outputObject, NSError *error) {
    //error occucs if error != nil
    }];
    [[QCloudCOSXMLService defaultCOSXML] PutBucketACL:putACL];

</code></pre>
<h3 id='cors' class='heading'>获取存储桶的CORS(跨域访问)设置</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudPutBucketCORSRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudPutBucketCORSRequest，填入需要获取CORS的bucket。<br>
2.调用QCloudCOSXMLService对象中的GetBucketCORS方法发出请求。<br>
3.从回调的finishBlock中获取结果。结果封装在了QCloudCORSConfiguration对象中，该对象的rules属性是一个数组，数组里存放着一组QCloudCORSRule，具体的CORS设置就封装在QCloudCORSRule对象里。   </p>
<h4 id='qcloudputbucketcorsrequest' class='heading'>QCloudPutBucketCORSRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
</tbody></table>
<h4 id='qcloudcorsconfiguration' class='heading'>返回结果QCloudCORSConfiguration参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>rules</td>
<td>NSArray<QCloudCORSRule*> *</td>
<td>放置CORS的数组, 数组内容为QCloudCORSRule实例</td>
</tr>
</tbody></table>
<h4 id='qcloudcorsrule' class='heading'>QCloudCORSRule参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>identifier</td>
<td>NSString *</td>
<td>配置规则的ID</td>
</tr>
<tr>
<td>allowedMethod</td>
<td>NSArray<NSString*> *</td>
<td>允许的 HTTP 操作，枚举值：GET，PUT，HEAD，POST，DELETE</td>
</tr>
<tr>
<td>allowedOrigin</td>
<td>NSString *</td>
<td>允许的访问来源，支持通配符 * , 格式为：协议://域名[:端口]如：<a href="http://www.qq.com">http://www.qq.com</a></td>
</tr>
<tr>
<td>allowedHeader</td>
<td>NSArray<NSString * > *</td>
<td>在发送 OPTIONS 请求时告知服务端，接下来的请求可以使用哪些自定义的 HTTP 请求头部，支持通配符 *</td>
</tr>
<tr>
<td>maxAgeSeconds</td>
<td>int</td>
<td>设置 OPTIONS 请求得到结果的有效期</td>
</tr>
<tr>
<td>exposeHeader</td>
<td>NSString *</td>
<td>设置浏览器可以接收到的来自服务器端的自定义头部信息</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>    QCloudGetBucketCORSRequest* corsReqeust = [QCloudGetBucketCORSRequest new];
    corsReqeust.bucket = self.bucket;

    [corsReqeust setFinishBlock:^(QCloudCORSConfiguration * _Nonnull result, NSError * _Nonnull error) {
        //CORS设置封装在result中。

    }];

    [[QCloudCOSXMLService defaultCOSXML] GetBucketCORS:corsReqeust];

</code></pre>
<h3 id='cors' class='heading'>设置存储桶的CORS（跨域访问）</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudPutBucketCORSRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudPutBucketCORSRequest，设置bucket，并且将需要的CORS装入QCloudCORSRule中，如果有多组CORS设置，可以将多个QCloudCORSRule放在一个NSArray里，然后将该数组填入QCloudCORSConfiguration的rules属性里，放在request中。<br>
2.调用QCloudCOSXMLService对象中的PutBucketCORS方法发出请求。<br>
3.从回调的finishBlock中的获取设置成功与否（error是否为空），并且做一些设置后的额外动作。   </p>
<h4 id='qcloudputbucketcorsrequest' class='heading'>QCloudPutBucketCORSRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>corsConfiguration</td>
<td>QCloudCORSConfiguration *</td>
<td>是</td>
<td>封装了CORS的具体参数</td>
</tr>
</tbody></table>
<h4 id='qcloudcorsconfiguration' class='heading'>QCloudCORSConfiguration参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>rules</td>
<td>NSArray<QCloudCORSRule*> *</td>
<td>放置CORS的数组, 数组内容为QCloudCORSRule实例</td>
</tr>
</tbody></table>
<h4 id='qcloudcorsrule' class='heading'>QCloudCORSRule参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>identifier</td>
<td>NSString *</td>
<td>配置规则的ID</td>
</tr>
<tr>
<td>allowedMethod</td>
<td>NSArray<NSString*> *</td>
<td>允许的 HTTP 操作，枚举值：GET，PUT，HEAD，POST，DELETE</td>
</tr>
<tr>
<td>allowedOrigin</td>
<td>NSString *</td>
<td>允许的访问来源，支持通配符 * , 格式为：协议://域名[:端口]如：<a href="http://www.qq.com">http://www.qq.com</a></td>
</tr>
<tr>
<td>allowedHeader</td>
<td>NSArray<NSString * > *</td>
<td>在发送 OPTIONS 请求时告知服务端，接下来的请求可以使用哪些自定义的 HTTP 请求头部，支持通配符 *</td>
</tr>
<tr>
<td>maxAgeSeconds</td>
<td>int</td>
<td>设置 OPTIONS 请求得到结果的有效期</td>
</tr>
<tr>
<td>exposeHeader</td>
<td>NSString *</td>
<td>设置浏览器可以接收到的来自服务器端的自定义头部信息</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>    QCloudPutBucketCORSRequest* putCORS = [QCloudPutBucketCORSRequest new];
    QCloudCORSConfiguration* cors = [QCloudCORSConfiguration new];

    QCloudCORSRule* rule = [QCloudCORSRule new];
    rule.identifier = @"sdk";
    rule.allowedHeader = @[@"origin",@"host",@"accept",@"content-type",@"authorization"];
    rule.exposeHeader = @"ETag";
    rule.allowedMethod = @[@"GET",@"PUT",@"POST", @"DELETE", @"HEAD"];
    rule.maxAgeSeconds = 3600;
    rule.allowedOrigin = @"*";

    cors.rules = @[rule];

    putCORS.corsConfiguration = cors;
    putCORS.bucket = @"您要设置的bucket";
    [putCORS setFinishBlock:^(id outputObject, NSError *error) {
        if (!error) {
        //success
        }
    }];
    [[QCloudCOSXMLService defaultCOSXML] PutBucketCORS:putCORS];



</code></pre>
<h3 id='' class='heading'>获取存储桶的地域信息</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudGetBucketLocationRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudGetBucketLocationRequest，填入bucket名。<br>
2.调用QCloudCOSXMLService对象中的GetBucketLocation方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qcloudgetbucketlocationrequest' class='heading'>QCloudGetBucketLocationRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
</tbody></table>
<h4 id='qcloudbucketlocationconstraint' class='heading'>返回结果QCloudBucketLocationConstraint参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>locationConstraint</td>
<td>NSString*</td>
<td>说明 Bucket 所在区域，枚举值：cn-north，cn-east，sg，cn-southwest，cn-south</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>
  QCloudGetBucketLocationRequest* locationReq = [QCloudGetBucketLocationRequest new];
    locationReq.bucket = @"您的bucket名";
    __block QCloudBucketLocationConstraint* location;
    [locationReq setFinishBlock:^(QCloudBucketLocationConstraint * _Nonnull result, NSError * _Nonnull error) {
        location = result;
    }];
    [[QCloudCOSXMLService defaultCOSXML] GetBucketLocation:locationReq];

</code></pre>
<h3 id='cors' class='heading'>删除存储桶CORS设置</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudDeleteBucketCORSRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudDeleteBucketCORSRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qclouddeletebucketcorsrequest' class='heading'>QCloudDeleteBucketCORSRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code> QCloudDeleteBucketCORSRequest* deleteCORS = [QCloudDeleteBucketCORSRequest new];
    deleteCORS.bucket = self.bucket;
    [deleteCORS setFinishBlock:^(id outputObject, NSError *error) {
        //success if error == nil
    }];
    [[QCloudCOSXMLService defaultCOSXML] DeleteBucketCORS:deleteCORS];
</code></pre>
<h3 id='bucket' class='heading'>查询Bucket中正在进行的分块上传</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行存储桶操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudListBucketMultipartUploadsRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudListBucketMultipartUploadsRequest，填入需要的参数，如返回结果的前缀、编码方式等。<br>
2.调用QCloudCOSXMLService对象中的ListBucketMultipartUploads方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qcloudlistbucketmultipartuploadsrequest' class='heading'>QCloudListBucketMultipartUploadsRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>prefix</td>
<td>NSString *</td>
<td>否</td>
<td>限定返回的 Object key 必须以 Prefix 作为前缀。</td>
</tr>
<tr>
<td>注意使用 prefix 查询时，返回的 key 中仍会包含 Prefix</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>delimiter</td>
<td>NSString *</td>
<td>否</td>
<td>定界符为一个符号，如果有 Prefix，则将 Prefix 到 delimiter 之间的相同路径归为一类，定义为 Common Prefix，然后列出所有 Common Prefix。如果没有 Prefix，则从路径起点开始</td>
</tr>
<tr>
<td>encodingType</td>
<td>NSString *</td>
<td>否</td>
<td>规定返回值的编码方式，可选值:url</td>
</tr>
<tr>
<td>keyMarker</td>
<td>NSString *</td>
<td>否</td>
<td>列出条目从该 key 值开始</td>
</tr>
<tr>
<td>uploadIDMarker</td>
<td>int</td>
<td>否</td>
<td>列出条目从该 UploadId 值开始</td>
</tr>
<tr>
<td>maxUploads</td>
<td>int</td>
<td>否</td>
<td>设置最大返回的multipart数量，合法值1到1000</td>
</tr>
</tbody></table>
<h4 id='qcloudlistmultipartuploadsresult' class='heading'>返回结果QCloudListMultipartUploadsResult参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>prefix</td>
<td>NSString *</td>
<td>否</td>
<td>限定返回的 Object key 必须以 Prefix 作为前缀。注意使用 prefix 查询时，返回的 key 中仍会包含 Prefix</td>
</tr>
<tr>
<td>delimiter</td>
<td>NSString *</td>
<td>否</td>
<td>定界符为一个符号，如果有 Prefix，则将 Prefix 到 delimiter 之间的相同路径归为一类，定义为 Common Prefix，然后列出所有 Common Prefix。如果没有 Prefix，则从路径起点开始</td>
</tr>
<tr>
<td>encodingType</td>
<td>NSString *</td>
<td>否</td>
<td>规定返回值的编码方式，可选值:url</td>
</tr>
<tr>
<td>keyMarker</td>
<td>NSString *</td>
<td>否</td>
<td>列出条目从该 key 值开始</td>
</tr>
<tr>
<td>maxUploads</td>
<td>int</td>
<td>否</td>
<td>设置最大返回的multipart数量，合法值1到1000</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code> QCloudListBucketMultipartUploadsRequest* uploads = [QCloudListBucketMultipartUploadsRequest new];
    uploads.bucket = self.bucket;
    uploads.maxUploads = 1000;
    __block NSError* resulError;
    __block QCloudListMultipartUploadsResult* multiPartUploadsResult;
    [uploads setFinishBlock:^(QCloudListMultipartUploadsResult* result, NSError *error) {
        multiPartUploadsResult = result;
        localError = error;
    }];
    [[QCloudCOSXMLService defaultCOSXML] ListBucketMultipartUploads:uploads];

</code></pre>
<h2 id='' class='heading'>文件操作</h2>

<p>在COS中，每个文件就是一个Object(对象)。对文件的操作，其实也就是对对象的操作。</p>
<h3 id='acl-access-control-list' class='heading'>查询对象的ACL（Access Control List）</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudGetObjectACLRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudGetObjectACLRequest，填入存储桶的名称，和需要查询对象的名称。<br>
2.调用QCloudCOSXMLService对象中的GetObjectACL方法发出请求。<br>
3.从回调的finishBlock中的获取的QCloudACLPolicy对象中获取封装好的ACL的具体信息。   </p>
<h4 id='qcloudgetobjectaclrequest' class='heading'>QCloudGetObjectACLRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code> request.bucket = self.aclBucket;
    request.object = @"对象的名称";
    request.bucket = @"对象所在bucket"
    __block QCloudACLPolicy* policy;
    [request setFinishBlock:^(QCloudACLPolicy * _Nonnull result, NSError * _Nonnull error) {
        policy = result;
    }];
    [[QCloudCOSXMLService defaultCOSXML] GetObjectACL:request];


</code></pre>
<h3 id='acl-access-control-list' class='heading'>设置对象的ACL（Access Control List）</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行对象操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudPutObjectACLRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudPutObjectACLRequest，填入bucket名，和一些额外需要的参数，如授权的具体信息等。<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中获取设置的完成情况，若error为空，则设置成功。   </p>
<h4 id='qcloudputobjectaclrequest' class='heading'>QCloudPutObjectACLRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSString *</td>
<td>否</td>
<td>定义 Object 的 ACL 属性。有效值：private，public-read-write，public-read；默认值：private</td>
</tr>
<tr>
<td>grantRead</td>
<td>NSString *</td>
<td>否</td>
<td>赋予被授权者读的权限。格式： id=&ldquo; <q>,id=</q> <q>；当需要给子账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;SubUin&gt;<q>，当需要给根账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;OwnerUin&gt;&rdquo;  其中OwnerUin指的是根账户的ID，而SubUin指的是子账户的ID</td>
</tr>
<tr>
<td>grantWrite</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者写的权限。格式同上。</td>
</tr>
<tr>
<td>grantFullControl</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者读写权限。格式同上。</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>    QCloudPutObjectACLRequest* request = [QCloudPutObjectACLRequest new];
    request.object = @"需要设置ACL的对象名";
    request.bucket = @"对象所在存储桶名";
    NSString *ownerIdentifier = [NSString stringWithFormat:@"qcs::cam::uin/%@:uin/%@",self.appID, self.appID];
    NSString *grantString = [NSString stringWithFormat:@"id=\"%@\"",ownerIdentifier];
    request.grantFullControl = grantString;
    __block NSError* localError;
    [request setFinishBlock:^(id outputObject, NSError *error) {
        localError = error;
    }];

    [[QCloudCOSXMLService defaultCOSXML] PutObjectACL:request];
</code></pre>
<h3 id='' class='heading'>下载文件</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='' class='heading'>参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>range</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616 中定义的指定文件下载范围，以字节（bytes）为单位</td>
</tr>
<tr>
<td>ifModifiedSince</td>
<td>NSString *</td>
<td>否</td>
<td>如果文件修改时间晚于指定时间，才返回文件内容。否则返回 412 (not modified)</td>
</tr>
<tr>
<td>responseContentType</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的 Content-Type参数</td>
</tr>
<tr>
<td>responseContentLanguage</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的Content-Language参数</td>
</tr>
<tr>
<td>responseContentExpires</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的Content-Expires参数</td>
</tr>
<tr>
<td>responseCacheControl</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的Cache-Control参数</td>
</tr>
<tr>
<td>responseContentDisposition</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的 Content-Disposition 参数。</td>
</tr>
<tr>
<td>responseContentEncoding</td>
<td>NSString *</td>
<td>否</td>
<td>设置响应头部中的 Content-Encoding 参数</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>  QCloudGetObjectRequest* request = [QCloudGetObjectRequest new];
  //设置下载的路径URL，如果设置了，文件将会被下载到指定路径中
  request.downloadingURL = [NSURL URLWithString:QCloudTempFilePathWithExtension(@"downding")];
  request.object = @“你的Object-Key”;
  request.bucket = @"你的bucket名";
  [request setFinishBlock:^(id outputObject, NSError *error) {
    //additional actions after finishing
}];
    [request setDownProcessBlock:^(int64_t bytesDownload, int64_t totalBytesDownload, int64_t totalBytesExpectedToDownload) {
     //下载过程中的进度
    }];
    [[QCloudCOSXMLService defaultCOSXML] GetObject:request];
</code></pre>
<h3 id='object' class='heading'>Object 跨域访问配置的预请求</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudOptionsObjectRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudOptionsObjectRequest，填入需要设置的对象名、存储桶名、模拟跨域访问请求的http方法和模拟跨域访问允许的访问来源<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qcloudoptionsobjectrequest' class='heading'>QCloudOptionsObjectRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
<tr>
<td>accessControlRequestMethod</td>
<td>NSArray<NSString*> *</td>
<td>是</td>
<td>模拟跨域访问的请求HTTP方法</td>
</tr>
<tr>
<td>origin</td>
<td>NSString *</td>
<td>是</td>
<td>模拟跨域访问允许的访问来源，支持通配符 * , 格式为：协议://域名[:端口]如：<a href="http://www.qq.com">http://www.qq.com</a></td>
</tr>
<tr>
<td>allowedHeader</td>
<td>NSArray<NSString * > *</td>
<td>否</td>
<td>在发送 OPTIONS 请求时告知服务端，接下来的请求可以使用哪些自定义的 HTTP 请求头部，支持通配符 *</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>
 QCloudOptionsObjectRequest* request = [[QCloudOptionsObjectRequest alloc] init];
    request.bucket =@"存储桶名";
    request.origin = @"*";
    request.accessControlRequestMethod = @"get";
    request.accessControlRequestHeaders = @"host";
    request.object = @"对象名";
    __block id resultError;
    [request setFinishBlock:^(id outputObject, NSError* error) {
        resultError = error;
    }];

    [[QCloudCOSXMLService defaultCOSXML] OptionsObject:request];



</code></pre>
<h3 id='' class='heading'>删除单个对象</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudDeleteObjectRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudDeleteObjectRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qclouddeleteobjectrequest' class='heading'>QCloudDeleteObjectRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>存储桶名</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>
QCloudDeleteObjectRequest* deleteObjectRequest = [QCloudDeleteObjectRequest new];
    deleteObjectRequest.bucket = @"存储桶名";
    deleteObjectRequest.object = @"对象名";

    __block NSError* resultError;
    [deleteObjectRequest setFinishBlock:^(id outputObject, NSError *error) {
        resultError = error;
    }];
    [[QCloudCOSXMLService defaultCOSXML] DeleteObject:deleteObjectRequest];

</code></pre>
<h3 id='' class='heading'>删除多个对象</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudDeleteMultipleObjectRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudDeleteMultipleObjectRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qclouddeletemultipleobjectrequest' class='heading'>QCloudDeleteMultipleObjectRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>deleteObjects</td>
<td>QCloudDeleteInfo *</td>
<td>是</td>
<td>封装了需要批量删除的多个对象的信息</td>
</tr>
</tbody></table>
<h4 id='qclouddeleteinfo' class='heading'>QCloudDeleteInfo参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>objects</td>
<td>NSArray<QCloudDeleteObjectInfo * > *</td>
<td>是</td>
<td>存放需要删除对象信息的数组</td>
</tr>
</tbody></table>
<h4 id='qclouddeleteobjectinfo' class='heading'>QCloudDeleteObjectInfo参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>key</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>
QCloudDeleteMultipleObjectRequest* delteRequest = [QCloudDeleteMultipleObjectRequest new];
    delteRequest.bucket = self.aclBucket;

    QCloudDeleteObjectInfo* deletedObject0 = [QCloudDeleteObjectInfo new];
    deletedObject0.key = @"第一个对象名";

    QCloudDeleteObjectInfo* deleteObject1 = [QCloudDeleteObjectInfo new];
    deleteObject1.key = @"第二个对象名";

    QCloudDeleteInfo* deleteInfo = [QCloudDeleteInfo new];
    deleteInfo.quiet = NO;
    deleteInfo.objects = @[ deletedObject0,deleteObject2];

    delteRequest.deleteObjects = deleteInfo;

    __block NSError* resultError;
    [delteRequest setFinishBlock:^(QCloudDeleteResult* outputObject, NSError *error) {
        localError = error;
        deleteResult = outputObject;
    }];


    [[QCloudCOSXMLService defaultCOSXML] DeleteMultipleObject:delteRequest];


</code></pre>
<h3 id='' class='heading'>初始化分片上传</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudInitiateMultipartUploadRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudInitiateMultipartUploadRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的InitiateMultipartUpload方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='' class='heading'>参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>Object</td>
<td>NSString *</td>
<td>是</td>
<td>上传文件（对象）的文件名，也是对象的key</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>上传的存储桶的名称</td>
</tr>
<tr>
<td>body</td>
<td>BodyType</td>
<td>是</td>
<td>需要上传的文件的路径。填入NSURL * 类型变量</td>
</tr>
<tr>
<td>storageClass</td>
<td>QCloudCOSStorageClass</td>
<td>是</td>
<td>对象的存储级别</td>
</tr>
<tr>
<td>cacheControl</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的缓存策略</td>
</tr>
<tr>
<td>contentDisposition</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的文件名称</td>
</tr>
<tr>
<td>expect</td>
<td>NSString *</td>
<td>否</td>
<td>当使用expect=@<q>100-continue</q>时，在收到服务端确认后才会发送请求内容</td>
</tr>
<tr>
<td>expires</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的过期时间</td>
</tr>
<tr>
<td>storageClass</td>
<td>QCloudCOSStorageClass</td>
<td>否</td>
<td>对象的存储级别</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSString *</td>
<td>否</td>
<td>定义 Object 的 ACL 属性。有效值：private，public-read-write，public-read；默认值：private</td>
</tr>
<tr>
<td>grantRead</td>
<td>NSString *</td>
<td>否</td>
<td>赋予被授权者读的权限。格式： id=&ldquo; <q>,id=</q> <q>；当需要给子账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;SubUin&gt;<q>，当需要给根账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;OwnerUin&gt;&rdquo;  其中OwnerUin指的是根账户的ID，而SubUin指的是子账户的ID</td>
</tr>
<tr>
<td>grantWrite</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者写的权限。格式同上。</td>
</tr>
<tr>
<td>grantFullControl</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者读写权限。格式同上。</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>
QCloudInitiateMultipartUploadRequest* initrequest = [QCloudInitiateMultipartUploadRequest new];
    initrequest.bucket = @"存储桶名";
    initrequest.object = @"object名";
    __block QCloudInitiateMultipartUploadResult* initResult;
    [initrequest setFinishBlock:^(QCloudInitiateMultipartUploadResult* outputObject, NSError *error) {
        initResult = outputObject;
    }];
    [[QCloudCOSXMLService defaultCOSXML] InitiateMultipartUpload:initrequest];

</code></pre>
<h3 id='meta' class='heading'>获取对象meta信息</h3>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudHeadObjectRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudHeadObjectRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的HeadObject方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qcloudheadobjectrequest' class='heading'>QCloudHeadObjectRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>Object</td>
<td>NSString *</td>
<td>是</td>
<td>对象名</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>对象所在存储桶的名称</td>
</tr>
<tr>
<td>ifModifiedSince</td>
<td>NSString *</td>
<td>是</td>
<td>如果文件修改时间晚于指定时间，才返回文件内容。否则返回 304 (not modified)</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code>QCloudHeadObjectRequest* headerRequest = [QCloudHeadObjectRequest new];
    headerRequest.object = @“对象名”;
    headerRequest.bucket = @"bucket名";

    __block id resultError;
    [headerRequest setFinishBlock:^(NSDictionary* result, NSError *error) {
        resultError = error;
    }];

    [[QCloudCOSXMLService defaultCOSXML] HeadObject:headerRequest];

</code></pre>
<h3 id='' class='heading'>追加文件</h3>

<p>Append Object 接口请求可以将一个 Object（文件）以分块追加的方式上传至指定 Bucket 中。Object 属性为 Appendable 时，才能使用 Append Object 接口上传。
Object 属性可以在 Head Object 操作中查询到，发起 Head Object 请求时，会返回自定义 Header 的『x-cos-object-type』，该 Header 只有两个枚举值：Normal 或者 Appendable。通过 Append Object 操作创建的 Object 类型为 Appendable 文件；通过 Put Object 上传的 Object 是 Normal 文件。
当 Appendable 的 Object 被执行 Put Object 的请求操作以后，原 Object 被覆盖，属性改变为 Normal 。
追加上传的 Object 建议大小 1M-5G。如果 Position 的值和当前 Object 的长度不致，COS 会返回 409 错误。如果 Append 一个 Normal 属性的文件，COS 会返回 409 ObjectNotAppendable。</p>
<h4 id='' class='heading'>方法原型</h4>

<p>进行文件操作之前，我们需要导入头文件QCloudCOSXML/QCloudCOSXML.h。在此之前您需要完成前文中的STEP-1初始化操作。先生成一个QCloudAppendObjectRequest实例，然后填入一些需要的额外的限制条件，通过并获得内容。具体步骤如下：<br>
1.实例化QCloudAppendObjectRequest，填入需要的参数。<br>
2.调用QCloudCOSXMLService对象中的AppendObject方法发出请求。<br>
3.从回调的finishBlock中的获取具体内容。   </p>
<h4 id='qcloudappendobjectrequest' class='heading'>QCloudAppendObjectRequest参数说明</h4>

<table><thead>
<tr>
<th>参数名称</th>
<th>类型</th>
<th>是否必填</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td>Object</td>
<td>NSString *</td>
<td>是</td>
<td>上传文件（对象）的文件名，也是对象的key</td>
</tr>
<tr>
<td>bucket</td>
<td>NSString *</td>
<td>是</td>
<td>上传的存储桶的名称</td>
</tr>
<tr>
<td>position</td>
<td>int</td>
<td>是</td>
<td>追加操作的起始点，单位：字节；首次追加 position=0，后续追加 position= 当前 Object 的 content-length</td>
</tr>
<tr>
<td>body</td>
<td>BodyType</td>
<td>是</td>
<td>需要上传的文件的路径。填入NSURL * 类型变量</td>
</tr>
<tr>
<td>storageClass</td>
<td>QCloudCOSStorageClass</td>
<td>是</td>
<td>对象的存储级别</td>
</tr>
<tr>
<td>cacheControl</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的缓存策略</td>
</tr>
<tr>
<td>contentDisposition</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的文件名称</td>
</tr>
<tr>
<td>expect</td>
<td>NSString *</td>
<td>否</td>
<td>当使用expect=@<q>100-continue</q>时，在收到服务端确认后才会发送请求内容</td>
</tr>
<tr>
<td>expires</td>
<td>NSString *</td>
<td>否</td>
<td>RFC 2616中定义的过期时间</td>
</tr>
<tr>
<td>storageClass</td>
<td>QCloudCOSStorageClass</td>
<td>否</td>
<td>对象的存储级别</td>
</tr>
<tr>
<td>accessControlList</td>
<td>NSString *</td>
<td>否</td>
<td>定义 Object 的 ACL 属性。有效值：private，public-read-write，public-read；默认值：private</td>
</tr>
<tr>
<td>grantRead</td>
<td>NSString *</td>
<td>否</td>
<td>赋予被授权者读的权限。格式： id=&ldquo; <q>,id=</q> <q>；当需要给子账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;SubUin&gt;<q>，当需要给根账户授权时，id=</q>qcs::cam::uin/&lt;OwnerUin&gt;:uin/&lt;OwnerUin&gt;&rdquo;  其中OwnerUin指的是根账户的ID，而SubUin指的是子账户的ID</td>
</tr>
<tr>
<td>grantWrite</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者写的权限。格式同上。</td>
</tr>
<tr>
<td>grantFullControl</td>
<td>NSString *</td>
<td>否</td>
<td>授予被授权者读写权限。格式同上。</td>
</tr>
</tbody></table>
<h4 id='' class='heading'>示例</h4>
<pre class="highlight plaintext"><code> QCloudAppendObjectRequest* put = [QCloudAppendObjectRequest new];
    put.object = [NSUUID UUID].UUIDString;
    put.bucket = @“bucket名”;
    put.body =  文件的URL，NSURL*类型
    __block NSDictionary* result = nil;
    [put setFinishBlock:^(id outputObject, NSError *error) {
        result = outputObject;
    }];
    [[QCloudCOSXMLService defaultCOSXML] AppendObject:put];

</code></pre>

          </section>
        </section>
        <section id="footer">
          <p>&copy; 2017 <a class="link" href="http://qcloud.com" target="_blank" rel="external">qcloud-terminal-lab</a>. All rights reserved. (Last updated: 2017-08-22)</p>
          <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.8.0</a>, a <a class="link" href="http://realm.io" target="_blank" rel="external">Realm</a> project.</p>
        </section>
      </article>
    </div>
  </body>
</div>
</html>
